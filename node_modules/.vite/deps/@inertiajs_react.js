import {
  De,
  Fe,
  Gr,
  Me,
  qe
} from "./chunk-3QM6O3HT.js";
import "./chunk-HZUWVUNY.js";
import {
  require_react
} from "./chunk-73THXJN7.js";
import {
  __commonJS,
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/lodash.isequal/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.isequal/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol = root.Symbol;
    var Uint8Array = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  }
});

// node_modules/@inertiajs/react/dist/index.esm.js
var import_react = __toESM(require_react());
var import_react2 = __toESM(require_react());
var import_react3 = __toESM(require_react());
var import_react4 = __toESM(require_react());
var import_react5 = __toESM(require_react());
var import_react6 = __toESM(require_react());
var import_react7 = __toESM(require_react());
var import_react8 = __toESM(require_react());
var import_lodash = __toESM(require_lodash());
var import_react9 = __toESM(require_react());
var import_react10 = __toESM(require_react());
var import_react11 = __toESM(require_react());
var import_react12 = __toESM(require_react());
var import_react13 = __toESM(require_react());
var Y = (0, import_react3.createContext)(void 0);
Y.displayName = "InertiaHeadContext";
var w = Y;
var z = (0, import_react4.createContext)(void 0);
z.displayName = "InertiaPageContext";
var O = z;
function H({ children: p, initialPage: r, initialComponent: s, resolveComponent: a, titleCallback: i, onHeadUpdate: P }) {
  let [l, m] = (0, import_react2.useState)({ component: s || null, page: r, key: null }), g = (0, import_react2.useMemo)(() => Fe(typeof window > "u", i || ((f) => f), P || (() => {
  })), []);
  if ((0, import_react2.useEffect)(() => {
    Gr.init({ initialPage: r, resolveComponent: a, swapComponent: async ({ component: f, page: e, preserveState: c }) => {
      m((n) => ({ component: f, page: e, key: c ? n.key : Date.now() }));
    } }), Gr.on("navigate", () => g.forceUpdate());
  }, []), !l.component) return (0, import_react2.createElement)(w.Provider, { value: g }, (0, import_react2.createElement)(O.Provider, { value: l.page }, null));
  let y = p || (({ Component: f, props: e, key: c }) => {
    let n = (0, import_react2.createElement)(f, { key: c, ...e });
    return typeof f.layout == "function" ? f.layout(n) : Array.isArray(f.layout) ? f.layout.concat(n).reverse().reduce((h, S) => (0, import_react2.createElement)(S, { children: h, ...e })) : n;
  });
  return (0, import_react2.createElement)(w.Provider, { value: g }, (0, import_react2.createElement)(O.Provider, { value: l.page }, y({ Component: l.component, key: l.key, props: l.page.props })));
}
H.displayName = "Inertia";
async function X({ id: p = "app", resolve: r, setup: s, title: a, progress: i = {}, page: P, render: l }) {
  let m = typeof window > "u", g = m ? null : document.getElementById(p), y = P || JSON.parse(g.dataset.page), f = (n) => Promise.resolve(r(n)).then((h) => h.default || h), e = [], c = await Promise.all([f(y.component), Gr.decryptHistory().catch(() => {
  })]).then(([n]) => s({ el: g, App: H, props: { initialPage: y, initialComponent: n, resolveComponent: f, titleCallback: a, onHeadUpdate: m ? (h) => e = h : null } }));
  if (!m && i && De(i), m) {
    let n = await l((0, import_react.createElement)("div", { id: p, "data-page": JSON.stringify(y) }, c));
    return { head: e, body: n };
  }
}
function V() {
  let p = (0, import_react6.useContext)(O);
  if (!p) throw new Error("usePage must be used within the Inertia component");
  return p;
}
var Z = ({ children: p, data: r, fallback: s }) => {
  if (!r) throw new Error("`<Deferred>` requires a `data` prop");
  let [a, i] = (0, import_react5.useState)(false), P = V().props, l = Array.isArray(r) ? r : [r];
  return (0, import_react5.useEffect)(() => {
    i(l.every((m) => P[m] !== void 0));
  }, [P, l]), a ? p : s;
};
Z.displayName = "InertiaDeferred";
var Ee = Z;
var De2 = function({ children: p, title: r }) {
  let s = (0, import_react7.useContext)(w), a = (0, import_react7.useMemo)(() => s.createProvider(), [s]);
  (0, import_react7.useEffect)(() => () => {
    a.disconnect();
  }, [a]);
  function i(e) {
    return ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"].indexOf(e.type) > -1;
  }
  function P(e) {
    let c = Object.keys(e.props).reduce((n, h) => {
      if (["head-key", "children", "dangerouslySetInnerHTML"].includes(h)) return n;
      let S = e.props[h];
      return S === "" ? n + ` ${h}` : n + ` ${h}="${S}"`;
    }, "");
    return `<${e.type}${c}>`;
  }
  function l(e) {
    return typeof e.props.children == "string" ? e.props.children : e.props.children.reduce((c, n) => c + m(n), "");
  }
  function m(e) {
    let c = P(e);
    return e.props.children && (c += l(e)), e.props.dangerouslySetInnerHTML && (c += e.props.dangerouslySetInnerHTML.__html), i(e) || (c += `</${e.type}>`), c;
  }
  function g(e) {
    return import_react7.default.cloneElement(e, { inertia: e.props["head-key"] !== void 0 ? e.props["head-key"] : "" });
  }
  function y(e) {
    return m(g(e));
  }
  function f(e) {
    let c = import_react7.default.Children.toArray(e).filter((n) => n).map((n) => y(n));
    return r && !c.find((n) => n.startsWith("<title")) && c.push(`<title inertia>${r}</title>`), c;
  }
  return a.update(f(p)), null;
};
var Me2 = De2;
var k = () => {
};
var ne = (0, import_react8.forwardRef)(({ children: p, as: r = "a", data: s = {}, href: a, method: i = "get", preserveScroll: P = false, preserveState: l = null, replace: m = false, only: g = [], except: y = [], headers: f = {}, queryStringArrayFormat: e = "brackets", async: c = false, onClick: n = k, onCancelToken: h = k, onBefore: S = k, onStart: R = k, onProgress: x = k, onFinish: B = k, onCancel: L = k, onSuccess: N = k, onError: A = k, prefetch: v = false, cacheFor: F = 0, ...t }, u) => {
  let [o, b] = (0, import_react8.useState)(0), d = (0, import_react8.useRef)(null);
  r = r.toLowerCase(), i = i.toLowerCase();
  let [fe, de] = qe(i, a || "", s, e);
  a = fe, s = de;
  let q = { data: s, method: i, preserveScroll: P, preserveState: l ?? i !== "get", replace: m, only: g, except: y, headers: f, async: c }, J = { ...q, onCancelToken: h, onBefore: S, onStart(T) {
    b(($) => $ + 1), R(T);
  }, onProgress: x, onFinish(T) {
    b(($) => $ - 1), B(T);
  }, onCancel: L, onSuccess: N, onError: A }, U = () => {
    Gr.prefetch(a, q, { cacheFor: me });
  }, I = (0, import_react8.useMemo)(() => v === true ? ["hover"] : v === false ? [] : Array.isArray(v) ? v : [v], Array.isArray(v) ? v : [v]), me = (0, import_react8.useMemo)(() => F !== 0 ? F : I.length === 1 && I[0] === "click" ? 0 : 3e4, [F, I]);
  (0, import_react8.useEffect)(() => () => {
    clearTimeout(d.current);
  }, []), (0, import_react8.useEffect)(() => {
    I.includes("mount") && setTimeout(() => U());
  }, I);
  let Q = { onClick: (T) => {
    n(T), Me(T) && (T.preventDefault(), Gr.visit(a, J));
  } }, ge = { onMouseEnter: () => {
    d.current = window.setTimeout(() => {
      U();
    }, 75);
  }, onMouseLeave: () => {
    clearTimeout(d.current);
  }, onClick: Q.onClick }, Pe = { onMouseDown: (T) => {
    Me(T) && (T.preventDefault(), U());
  }, onMouseUp: (T) => {
    T.preventDefault(), Gr.visit(a, J);
  }, onClick: (T) => {
    n(T), Me(T) && T.preventDefault();
  } };
  return i !== "get" && (r = "button"), (0, import_react8.createElement)(r, { ...t, ...{ a: { href: a }, button: { type: "button" } }[r] || {}, ref: u, ...(() => I.includes("hover") ? ge : I.includes("click") ? Pe : Q)(), "data-loading": o > 0 ? "" : void 0 }, p);
});
ne.displayName = "InertiaLink";
var Ue = ne;
function D(p, r) {
  let [s, a] = (0, import_react10.useState)(() => {
    let i = Gr.restore(r);
    return i !== void 0 ? i : p;
  });
  return (0, import_react10.useEffect)(() => {
    Gr.remember(s, r);
  }, [s, r]), [s, a];
}
function ae(p, r) {
  let s = (0, import_react9.useRef)(null), a = typeof p == "string" ? p : null, [i, P] = (0, import_react9.useState)((typeof p == "string" ? r : p) || {}), l = (0, import_react9.useRef)(null), m = (0, import_react9.useRef)(null), [g, y] = a ? D(i, `${a}:data`) : (0, import_react9.useState)(i), [f, e] = a ? D({}, `${a}:errors`) : (0, import_react9.useState)({}), [c, n] = (0, import_react9.useState)(false), [h, S] = (0, import_react9.useState)(false), [R, x] = (0, import_react9.useState)(null), [B, L] = (0, import_react9.useState)(false), [N, A] = (0, import_react9.useState)(false), v = (t) => t;
  (0, import_react9.useEffect)(() => (s.current = true, () => {
    s.current = false;
  }), []);
  let F = (0, import_react9.useCallback)((t, u, o = {}) => {
    let b = { ...o, onCancelToken: (d) => {
      if (l.current = d, o.onCancelToken) return o.onCancelToken(d);
    }, onBefore: (d) => {
      if (L(false), A(false), clearTimeout(m.current), o.onBefore) return o.onBefore(d);
    }, onStart: (d) => {
      if (S(true), o.onStart) return o.onStart(d);
    }, onProgress: (d) => {
      if (x(d), o.onProgress) return o.onProgress(d);
    }, onSuccess: (d) => {
      if (s.current && (S(false), x(null), e({}), n(false), L(true), A(true), m.current = setTimeout(() => {
        s.current && A(false);
      }, 2e3)), o.onSuccess) return o.onSuccess(d);
    }, onError: (d) => {
      if (s.current && (S(false), x(null), e(d), n(true)), o.onError) return o.onError(d);
    }, onCancel: () => {
      if (s.current && (S(false), x(null)), o.onCancel) return o.onCancel();
    }, onFinish: (d) => {
      if (s.current && (S(false), x(null)), l.current = null, o.onFinish) return o.onFinish(d);
    } };
    t === "delete" ? Gr.delete(u, { ...b, data: v(g) }) : Gr[t](u, v(g), b);
  }, [g, e, v]);
  return { data: g, setData(t, u) {
    y(typeof t == "string" ? (o) => ({ ...o, [t]: u }) : typeof t == "function" ? (o) => t(o) : t);
  }, isDirty: !(0, import_lodash.default)(g, i), errors: f, hasErrors: c, processing: h, progress: R, wasSuccessful: B, recentlySuccessful: N, transform(t) {
    v = t;
  }, setDefaults(t, u) {
    P(typeof t > "u" ? () => g : (o) => ({ ...o, ...typeof t == "string" ? { [t]: u } : t }));
  }, reset(...t) {
    t.length === 0 ? y(i) : y(Object.keys(i).filter((u) => t.includes(u)).reduce((u, o) => (u[o] = i[o], u), { ...g }));
  }, setError(t, u) {
    e((o) => {
      let b = { ...o, ...typeof t == "string" ? { [t]: u } : t };
      return n(Object.keys(b).length > 0), b;
    });
  }, clearErrors(...t) {
    e((u) => {
      let o = Object.keys(u).reduce((b, d) => ({ ...b, ...t.length > 0 && !t.includes(d) ? { [d]: u[d] } : {} }), {});
      return n(Object.keys(o).length > 0), o;
    });
  }, submit: F, get(t, u) {
    F("get", t, u);
  }, post(t, u) {
    F("post", t, u);
  }, put(t, u) {
    F("put", t, u);
  }, patch(t, u) {
    F("patch", t, u);
  }, delete(t, u) {
    F("delete", t, u);
  }, cancel() {
    l.current && l.current.cancel();
  } };
}
function ie(p, r = {}, s = { keepAlive: false, autoStart: true }) {
  let a = (0, import_react11.useRef)(Gr.poll(p, r, { ...s, autoStart: false }));
  return (0, import_react11.useEffect)(() => ((s.autoStart ?? true) && a.current.start(), () => a.current.stop()), []), { stop: a.current.stop, start: a.current.start };
}
function pe(p = {}) {
  let r = typeof window > "u" ? null : Gr.getCached(window.location.pathname, p), s = typeof window > "u" ? null : Gr.getPrefetching(window.location.pathname, p), [a, i] = (0, import_react12.useState)((r == null ? void 0 : r.staleTimestamp) || null), [P, l] = (0, import_react12.useState)(s !== null), [m, g] = (0, import_react12.useState)(r !== null);
  return (0, import_react12.useEffect)(() => {
    let y = Gr.on("prefetching", (e) => {
      e.detail.visit.url.pathname === window.location.pathname && l(true);
    }), f = Gr.on("prefetched", (e) => {
      e.detail.visit.url.pathname === window.location.pathname && (l(false), g(true), i(e.detail.fetchedAt));
    });
    return () => {
      f(), y();
    };
  }, []), { lastUpdatedAt: a, isPrefetching: P, isPrefetched: m, flush: () => Gr.flush(window.location.pathname, p) };
}
var ce = ({ children: p, data: r, params: s, buffer: a, as: i, always: P, fallback: l }) => {
  P = P ?? false, i = i ?? "div", l = l ?? null;
  let [m, g] = (0, import_react13.useState)(false), [y, f] = (0, import_react13.useState)(false), e = (0, import_react13.useRef)(null), c = (0, import_react13.useRef)(null), n = () => {
    if (r) return { only: Array.isArray(r) ? r : [r] };
    if (!s) throw new Error("You must provide either a `data` or `params` prop.");
    return s;
  };
  return (0, import_react13.useEffect)(() => {
    if (c.current) return e.current = new IntersectionObserver((h) => {
      var _a;
      if (!h[0].isIntersecting || (P || ((_a = e.current) == null ? void 0 : _a.disconnect()), y)) return;
      f(true);
      let S = n();
      Gr.reload({ ...S, onStart: (R) => {
        var _a2;
        f(true), (_a2 = S.onStart) == null ? void 0 : _a2.call(S, R);
      }, onFinish: (R) => {
        var _a2;
        g(true), f(false), (_a2 = S.onFinish) == null ? void 0 : _a2.call(S, R);
      } });
    }, { rootMargin: `${a || 0}px` }), e.current.observe(c.current), () => {
      var _a;
      (_a = e.current) == null ? void 0 : _a.disconnect();
    };
  }, [c]), P || !m ? (0, import_react13.createElement)(i, { props: null, ref: c }, m ? p : l) : m ? p : null;
};
ce.displayName = "InertiaWhenVisible";
var Ze = ce;
var hr = Gr;
export {
  Ee as Deferred,
  Me2 as Head,
  Ue as Link,
  Ze as WhenVisible,
  X as createInertiaApp,
  hr as router,
  ae as useForm,
  V as usePage,
  ie as usePoll,
  pe as usePrefetch,
  D as useRemember
};
//# sourceMappingURL=@inertiajs_react.js.map
